package config

import (
	"crypto/rand"
	"crypto/sha256"
	"crypto/tls"
	"fmt"
	"os"
	"path/filepath"
	"strconv"

	"github.com/ddvk/rmfakecloud/internal/email"
	log "github.com/sirupsen/logrus"
	"golang.org/x/crypto/pbkdf2"
)

const (
	// DefaultPort the default port
	DefaultPort = "3000"
	// DefaultDataDir default folder for storage
	DefaultDataDir = "data"

	// ReadStorageExpirationInMinutes time the token is valid
	ReadStorageExpirationInMinutes = 5
	// WriteStorageExpirationInMinutes time the token is valid
	WriteStorageExpirationInMinutes = 5

	// DefaultHost fake url
	DefaultHost = "local.appspot.com"

	// EnvLogLevel environment variable for the log level
	EnvLogLevel = "LOGLEVEL"
	// envDataDir
	envDataDir    = "DATADIR"
	envPort       = "PORT"
	envStorageURL = "STORAGE_URL"
	// envTLSCert the path of the cert file
	envTLSCert = "TLS_CERT"
	// envTLSKey the path of the private key
	envTLSKey = "TLS_KEY"

	// auth
	envJWTSecretKey     = "JWT_SECRET_KEY"
	envRegistrationOpen = "OPEN_REGISTRATION"

	// envSMTPServer the mail server
	envSMTPServer = "RM_SMTP_SERVER"
	// envSMTPUsername the username for the mail server
	envSMTPUsername = "RM_SMTP_USERNAME"
	// envSMTPPassword pass
	envSMTPPassword = "RM_SMTP_PASSWORD"
	// envSMTPHelo custom helo
	envSMTPHelo = "RM_SMTP_HELO"
	// envSMTPInsecureTLS dont check cert (bad)
	envSMTPInsecureTLS = "RM_SMTP_INSECURE_TLS"
	// envSMTPFrom custom from address
	envSMTPFrom = "RM_SMTP_FROM"

	// envHwrApplicationKey the myScript application key
	envHwrApplicationKey = "RMAPI_HWR_APPLICATIONKEY"
	// envHwrHmac myScript hmac key
	envHwrHmac = "RMAPI_HWR_HMAC"
	// envLogFile log file to use
	envLogFile     = "RM_LOGFILE"
	envHTTPSCookie = "RM_HTTPS_COOKIE"
)

// Config config
type Config struct {
	Port              string
	StorageURL        string
	DataDir           string
	RegistrationOpen  bool
	CreateFirstUser   bool
	JWTSecretKey      []byte
	JWTRandom         bool
	Certificate       tls.Certificate
	SMTPConfig        *email.SMTPConfig
	LogFile           string
	HWRApplicationKey string
	HWRHmac           string
	TokenVersion      int
	HTTPSCookie       bool
}

// Verify verify
func (cfg *Config) Verify() {
	if cfg.JWTRandom {
		log.Warnf("%s was not set! You have to set this variable in order for the Authentication to work, the following was autogenerated", envJWTSecretKey)
		log.Warnf("%s=%X", envJWTSecretKey, cfg.JWTSecretKey)
		log.Warn("The authentication will fail, the next time you start the server")
	}

	if cfg.SMTPConfig == nil {
		log.Warnln("smtp not configured, no emails will be sent")
	}

	if cfg.HWRApplicationKey == "" {
		log.Println("if you want HWR, provide the myScript applicationKey in: RMAPI_HWR_APPLICATIONKEY")
	}
	if cfg.HWRHmac == "" {
		log.Println("provide the myScript hmac in: RMAPI_HWR_HMAC")
	}
}

// FromEnv config from environment values
func FromEnv() *Config {
	var err error
	var dataDir string
	data := os.Getenv(envDataDir)
	if data != "" {
		dataDir = data
	} else {
		dataDir, err = filepath.Abs(DefaultDataDir)
		if err != nil {
			log.Fatal("DataDir: ", err)
		}
	}

	port := os.Getenv(envPort)
	if port == "" {
		port = DefaultPort
	}

	jwtGenerated := false
	jwtSecretKey := []byte(os.Getenv(envJWTSecretKey))
	if len(jwtSecretKey) == 0 {
		jwtSecretKey = make([]byte, 32)
		_, err := rand.Read(jwtSecretKey)
		if err != nil {
			log.Fatal(err)
		}
		jwtGenerated = true
	}
	dk := pbkdf2.Key(jwtSecretKey, []byte("todo some salt"), 10000, 32, sha256.New)

	var cert tls.Certificate
	certPath := os.Getenv(envTLSCert)
	keyPath := os.Getenv(envTLSKey)
	if certPath != "" && keyPath != "" {

		cert, err = tls.LoadX509KeyPair(certPath, keyPath)
		if err != nil {
			log.Fatal("unable to load certificate:", err)
		}
	}
	openRegistration, _ := strconv.ParseBool(os.Getenv(envRegistrationOpen))
	httpsCookie, _ := strconv.ParseBool(os.Getenv(envHTTPSCookie))

	uploadURL := os.Getenv(envStorageURL)
	if uploadURL == "" {
		//it will go through the local proxy
		uploadURL = "https://" + DefaultHost
	}

	// smtp
	var smtpCfg *email.SMTPConfig
	servername := os.Getenv(envSMTPServer)

	if servername != "" {
		inSecureTLS, _ := strconv.ParseBool(os.Getenv(envSMTPInsecureTLS))
		smtpCfg = &email.SMTPConfig{
			Server:       servername,
			Username:     os.Getenv(envSMTPUsername),
			Password:     os.Getenv(envSMTPPassword),
			Helo:         os.Getenv(envSMTPHelo),
			InsecureTLS:  inSecureTLS,
			FromOverride: os.Getenv(envSMTPFrom),
		}
	}
	// hwr

	cfg := Config{
		Port:              port,
		StorageURL:        uploadURL,
		DataDir:           dataDir,
		JWTSecretKey:      dk,
		JWTRandom:         jwtGenerated,
		Certificate:       cert,
		RegistrationOpen:  openRegistration,
		SMTPConfig:        smtpCfg,
		LogFile:           os.Getenv(envLogFile),
		HWRApplicationKey: os.Getenv(envHwrApplicationKey),
		HWRHmac:           os.Getenv(envHwrHmac),
		HTTPSCookie:       httpsCookie,
	}
	return &cfg
}

// EnvVars env vars usage
func EnvVars() string {
	return fmt.Sprintf(`
Environment Variables:

General:
	%s	Secret for signing JWT tokens
	%s	Log verbosity level (debug, info, warn) (default: info)
	%s		Port (default: %s)
	%s		Local storage folder (default: %s)
	%s	Url the tablet can resolve (default: https://local.apphost.com)
	%s	Path to the server certificate.
	%s		Path to the server certificate key.
	%s	Write logs to file
	%s Send auth cookie only via https

Emails, smtp:
	%s
	%s
	%s
	%s	don't check the server certificate (not recommended)
	%s	custom HELO (if your email server needs it)
	%s	override the email's From:

myScript hwr (needs a developer account):
	%s
	%s
`,
		envJWTSecretKey,
		EnvLogLevel,
		envPort,
		DefaultPort,
		envDataDir,
		DefaultDataDir,
		envStorageURL,
		envTLSCert,
		envTLSKey,
		envLogFile,
		envHTTPSCookie,

		envSMTPServer,
		envSMTPUsername,
		envSMTPPassword,
		envSMTPInsecureTLS,
		envSMTPHelo,
		envSMTPFrom,

		envHwrApplicationKey,
		envHwrHmac,
	)
}
